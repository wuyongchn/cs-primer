TODO

## 基本概念
运算符重载是具有特殊名字的函数：它们有关键字 operator 和其后要定义的运算符号共同组成

参数数量与该运算符作用的运算对象数量一样多

如果一个运算符函数是成员函数，则它的第一个（左侧）运算对象绑定到隐式的 this 指针上

优先级和结合率与对应的内置运算符保持一致

运算对象求值顺序的规则无法应用到重载的运算符号上


不能被重载的运算符（::, .*, ,, ?:）
  - 通常情况下，不应该重载的运算符（`，`， `&`， `&&`， `||`）
- 选择作为成员或者非成员
  - `=`、`[]`、`()`、`->` 必须是成员
  - 复合运算符一般来说应该是成员，但非必须
  - 改变对象状态的运算符或者与给定类型密切相关的运算符（`++`、`--`，`*`）通常是成员
  - 具有对称性的运算符通常作为普通函数
- 重载输出运算符 `<<`
  - 通常第一个形参是 `ostream &` ，第二个形参是一个常量的引用
  - 返回 `ostream &`
  - 尽量减少格式化操作
  - 必须是非成员函数（成员函数第一个参数默认为this）  
    `ostream &operator<<(ostream &os, const Tp &t);`
- 重载输入运算符 `>>`
  - 通常第一个形参是将要读取的流的引用，第二个形参是将要读入到的（非常量）对象的引用
  - 返回某个给定流的引用
  - 必须是非成员函数（成员函数第一个参数默认为 `this`）
  - 必须处理输入可能失败的情况
- 算术和关系运算符
  - 通常情况下，我们把算术和关系运算符定义成非成员函数以允许对左侧或右侧的运算对象进行转换
  - 返回局部变量的值
- 赋值运算符
  - 必须为成员函数
  - 复合赋值运算符不非得是类的成员，不过倾向于定义在类内
  - 返回左侧运算对象的引用
- 下标运算符
  - 必须是成员函数
  - 常以所访问元素的引用作为返回值
  - 最后同时定义常量版本和非常量版本
- 递增和递减运算符
  - 建议设定为成员函数
  - 同时定义前置版本和后置版本
  - 区分前置版本和后置版本，后置版本接受一个额外的（不被使用）`int` 类型的形参  
    `StrBlobPtr &operator++();`,`StrBlobPtr operator++(int);`
  - 前置版本对象的引用，后置版本返回副本的值
  - 显式调用后置运算符 `p.operator++(0);`
- 成员访问运算符 `*`、`->`
  - 箭头运算符必须是类的成员，解引用运算符通常也是类的成员，但不是必须
  - `point->men` 的执行过程
    - 第一步：如果 point 是指针，则引用内置的箭头运算符，表达式等价于 `(*point).men`。首先解引用该指针，然后从所得的对象中获取指定的成员。如果 point 所指的类型没有名为 mem 的成员，程序会发生错误。
    - 第二布：如果 point 是定义了 `operator->` 的类的一个对象，则使用 `point.operator->()` 的结果获取 mem。其中，如果该结果是一个指针，则执行第一步。如果该结果本身含有重载的 `operator->()`，则重复调用当前步骤。最终，当这一过程结束时程序或者返回了所需的内容，或者返回一些表示程序错误的信息。
- 函数调用运算符
  - 必须是成员函数
  - 可以重载
- `lambda` 是函数对象
  - 当我们编写了一个 `lambda` 后，编译器将该表达式翻译成一个**未命名类的未命名对象**
  - 含有一个重载的函数调用运算符
  - 默认情况下，函数调用运算符是 `const` 成员函数
  - 不含默认构造函数、赋值运算符及默认析构函数
- 调用形式
  - 调用形式指明了调用返回类型以及传递给调用的实参类型
- 标准库 function 类型
  - function 的操作
    - `function<T> f;` T为调用形式
    - `function<T> f(nullptr);` 空 function 对象
    - `function<T> f(obj);`
    - `f` 作为条件
    - `f(args)` 调用f中的对象
  - 可以把所有可调用对象，包括函数指针、`lambda` 或者函数对象赋值给 function，只要调用形式一样
    ```
    map<string, function<int(int, int)>> binops = {
      {"+", add},                                // 函数指针
      {"-", std::minus<int>()},                  // 标准库函数对象
      {"/", divide()},                           // 用户定义的函数对象
      {"*", [](int i, int j) { return i * j; }}, // 未命名的lambda对象
      {"%", mod}}                                // 命名的lambda对象
    ```
  - 不能（直接）将重载函数的名字存入 function 类型的对象（可转为存储函数指针）
- 类类型转换运算符  
  `operator type() const`： type 为某种类型
  - 负责将一个类类型的值转换成其他类型
  - 必须是类的成员函数，通常是 `const`
  - 不能声明返回类型
  - 隐式执行，无法传递实参，所以形参列表必须为空
  - 不允许转换成数组或者函数类型，但允许转换成指针（包括数组指针及函数指针）或引用类型
  - 加 `explicit` 显示转换（`static_cast<>`），编译器不会隐式转换。在下列位置，会被隐式执行
    - `if`、`while` 及 `do` 语句的条件部分
    - `for` 语句头的条件表达式
    - 逻辑非、或、与的运算对象
    - 条件运算符（`? :`）的条件表达式
  - 避免有二义性的类型转换（只存在唯一一种转换方式）
    - 不要令两个类执行相同的类型转换：如果 Foo 类有个接受 Bar 类对象的构造函数，则不要在 Bar 类中在定义转换目标为 Foo 类的类型转换运算符
    - 避免转换目标是内置算术类型的类型转换。特别是定义类转换成算术类型的转换类型的时候，接下来
      - 不要在定义接受算术类型的运算符重载
      - 不要定义转换到多种算术类型的类型转换
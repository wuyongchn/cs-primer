TODO(用于大型程序的工具)

- 当执行一个 `throw` 时，跟在 `throw` 后面的语句将不再执行。相反，程序的控制权从 `throw` 转移到与之匹配的 `catch` 模块
- 栈展开  
  如果对抛出异常的函数的调用位于一个 `try` 语句块内，则检查与该 `try` 块关联的 `catch` 子句。如果找到了匹配的 `catch`，就使用该 `catch` 处理异常。否则，如果该 `try` 语句嵌套在其他 `try` 语句块中，则继续检查与外层 `try` 匹配的 `catch` 子句。如果仍然没有找到匹配的 `catch`，则推出当前这个主调函数，继续在调用刚刚退出的这个函数的其他函数中寻找名，以此类推（沿着嵌套函数的调用链不断查找，知道找到了与异常匹配的 `catch` 子句为止，如果一直没找到匹配的 `catch`，则退出主函数后查找过程终止）。
- 栈展开过程中的对象被自动销毁
  - 如果异常发生在构造函数中，要确保已构造的成员能被正确地销毁
- 析构函数和异常
  - 析构函数总是被执行，但是函数中负责释放资源的代码却可能被跳过
  - 析构函数在栈展开的过程中执行（不应该抛出异常，一旦抛出异常且析构函数自身没能捕获到该异常，则程序终止）
  - 析构函数中可能抛出异常的操作应该放在 `try` 语句块中，并且在自己内部得到处理
- 查找匹配的处理代码
  - 按照 `catch` 语句的出现顺序逐一进行匹配，选择第一个与异常匹配的 `catch` 语句（异常类继承链最底端放在前面）
  - 绝大多数类型转换都不被允许，要求精确匹配
    - 允许从非常量向常量的类型转换
    - 允许从派生类向基类的类型转换
    - 数组被转换成指针，函数被转换成指针
- 重新抛出
  - `catch` 语句通过重新抛出将异常传递给另外一个 `catch` 语句
  - 用 `throw;`，不包含任何表达式
  - 只有当 `catch` 异常声明是引用类型时，对参数所做的改变才会被保留并继续传播
- 捕获所有异常 `catch(...) {/*....*/}`
- 函数 `try` 语句块
  ```
  template <typename T>
  Blob<T>::Blob(std::initializer_list<T> il) try :
      data(std::make_shared<std::vector<T>>(il)) {
    /*constructor*/
  } catch(const std::bad_alloc &e) { hand_out_of_memeory(e); }

  template <typename T>
  Blob<T>::~Blob() try  {
    / *deconstructor*/
  } catch(exception &e) { /*...*/}
  ```
  - 既能处理构造函数体（或析构函数体），也能处理构造函数的初始化过程（或析构函数的析构过程）的异常
  - 关键字出现在构造函数初始值列表的冒号以及表示构造函数体的化括号之前
- `noexcept` 异常说明
  - 指定某个函数不会抛出异常
  - 关键词 `noexcept` 紧跟在函数的参数列表后面；**在成员函数中，`noexcept` 需要跟在 `const` 以及引用限定符之后，而在 `final`、`override` 或虚函数的 `=0` 之前**
    ```
    void recoup(int) noexcept; // 不抛出异常
    void recoup(int) throw();  // 等价的声明（兼容性）
    ```
  - 违反异常说明
    - 一旦一个 `noexcept` 函数抛出了异常，程序就会调用 `terminate` 结束程序以确保遵守不在运行时抛出异常的承诺
  - 异常说明的实参
    - 可选实参，该实参必须能转换为 `bool` 类型，`true` 代表不抛出异常
      ```
      void recoup(int) noexcept(true);   // 不抛出异常
      void alloc(int) noexcept(false);  // 可能爆出异常
      ```
  - `noexcept` 运算符
    - 一元运算符，返回 `bool`，用于表示给定的表达式是(`true`)否(`false`)抛出异常 `noexcept(recoup(i));`
  - 异常说明与指针、虚函数和拷贝控制
    - 函数指针及该指针所指的函数必须具有一致的异常说明
    - 如果一个虚函数不抛出异常，则后续派生出来的虚函数也不能抛出异常；与之相反，虚函数抛出异常，派生类中不做要求（可以、不可以都行）
    - 合成拷贝控制成员时，如果调用的任意一个函数可能抛出异常，则合成的成员是 `noexcept(false)`
- 异常类层次
  - `exception` 仅仅定义了拷贝构造函数、拷贝赋值运算符、一个虚析构函数和一个名为 waht 的虚成员
  - what 负责返回用于初始化异常对象的信息（异常类名字之类的）
- 命名空间
  - 定义
    ```
    namespace name{
      /*
      class, vairable, function, template, other namespace 
      */
    }
    ```
  - 每个命名空间都是一个作用域
  - 可以不是连续的（可以定义在几个不用的部分）  
    `namespace nsp{/*...*/}`：可能定义一个新的命名空间，也可能是为已经存在的命名空间添加一些成员
  - 模板特例化
    - 必须定义在原始模板所属的命名空间中 `namespace std { template <> struct hash<Blob>{/*...*/}; }`
  - 全局命名空间
    - 全局定义中的名字也就是定义在全局命名空间中
    - 所有程序都存在
    - `::member_name`
  - 内联命名空间 `inline namespace snp {/*...*/}`
    - 内联命名空间中的名字可以被外层命名空间直接使用
    - `inline`必须出现在第一次定义的地方
  - 未命名的命名空间
    - 未命名的命名空间中定义的变量拥有静态生命周期
    - 可以在给定的文件中不连续，但不能跨越多个文件（作用范围不会横跨多个不用的文件）
    - 定义在未命名的命名空间中的名字可以直接使用
  - 使用命名空间中的成员
    - 命名空间别名 `namespace other_name = origin_name;`
    - using声明
      - 一条using声明语句一次只能引入命名空间的一个成员`using std::vector;`
      - 声明的是一个名字，而非一个特定的函数
      - 外层作用域的同名实体将被隐藏，参数列表相同发生错误
      - 为引入的名字添加而外的重载实例，并最终扩充候选函数集的规模
    - using指示
      - 所有名字都可见`using namespace std;`
      - 可以出现在全局作用域、局部作用域和命名空间作用域，但不能出现在类的作用域中
      - 为引入的名字添加而外的重载实例，并最终扩充候选函数集的规模
      - 参数列表完全相同不会发生错误，使用是必须指定特定的版本
- 类、命名空间与作用域
  - 由内向外依次查找每个外层作用域
  - 实参相关的查找与类类型形参
    - 当给函数传递一个类类型的对象时，除了在常规的作用域查找外，还会查找实参类所属的命名空间
  - 友元声明与实参相关的查找
    - 一个另外声明的类或函数如果第一次出现在友元声明中，则我们认为它是最近的外层命名空间的成员
- 多重继承
  - 在某个给定的派生列表中，同一个基类只能出现一次
  - 派生类的构造函数只能负责初始化它的直接基类，不能从多个基类中继承相同的构造函数
  - 基类的构造顺序与派生列表中基类出现顺序保持一致，与初始化值列表中基类的顺序无关
  - 派生类的析构函数只负责本身分配的资源
  - 可以令某个可访问基类的指针或引用直接指向一个派生类
  - 查找过程在所有直接基类中**同时进行**，如果名字在多个基类中被找到，则使用该名字具有二义性
- 虚继承
  ```
  class Raccoon: public virtual ZooAnimal { /*...*/ }; // virtual 和 public的顺序无关
  class Bear: virtual public ZooAnimal { /*...*/ };
  class Panda: public Bear, public Raccoon, public Endangered { /*...*/ };
  ```
  - 令某个类作出声明，承诺cany共享它的基类
  - 派生类中只包含唯一一个共享的虚基类子对象
  - 虚派生只影响从指定了虚基类的派生类进一步派生出的类
  - 基类的成员可以被直接访问
  - 派生类首先初始化虚基类子部分，接下来按照直接基类在派生类派生列表的次序进行初始化
  - 析构顺序与构造顺序相反
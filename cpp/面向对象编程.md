TODO

## OPP 概述
面向对象编程三个重要的概念分别是：数据抽象、继承和动态绑定。[数据抽象](./类.md)将接口和实现分离。继承可以为相似的类型建模。而动态绑定实现动态。

## 基类和派生类
```
class Base {
public:
    Base() = default;
    virtual ~Base();
    virtual virtualFunc();
    void nonOverride() final;
};

class Derive : public Base {
public:
    Derive() = default;
    ~Derive();
    virtualFunc() override;
};
```
  - 析构函数通常为虚函数
  - `virtual` 只能出现在类内部的声明语句之前而不能用于类外部的函数定义
  - 被用作基类的类必须是已经定义而非仅仅声明
  - 在类名后加 `final` 可以防止被继承
- 定义派生类
  - 使用类派生列表指明继承关系
  - 必须将继承而来的成员函数中需要覆盖的那些重新声明
  - 允许派生类显式地注明它使用某个成员函数覆盖类它继承的虚函数：在形参列表、或者在 `const` 成员函数的 `const` 关键字后面、或者在引用成员函数的引用限定符后面加 `override`
  - 派生类必须使用基类的构造函数来初始化它的基类部分
  - 派生类可以访问基类的公有成员和受保护成员
  - 如果基类定义了一个静态成员，则在整个继承体系中只存在该成员的唯一定义
  - 静态成员遵循通用的访问控制规则
- 类类型转换与继承
  - 可以将基类的指针（智能指针也可以）或引用绑定到派生类对象上
  - 不存在从基类向派生类的隐式类型转换，在对象间不存在类型转换
  - 当用一个派生类对象为一个基类对象初始化或赋值时，只有该派生类对象中的基类部分会被拷贝、移动或赋值，它的派生类部分会被忽略掉

## 虚函数
  - 所有虚函数都必须有定义
  - 对虚函数的调用可能在运行时才被解析
  - 一旦某个函数被声明为虚函数，则在所有派生类中它都是虚函数
  - 派生类中的函数只有与基类虚函数的调用形式一样（有一个例外，返回对象本身的指针或应用）才构成覆盖（重写）
  - `override` 关键字显式说明派生类覆盖继承于基类的一个虚函数（编译器会帮助检查是否覆盖**虚函数**，没有的话会报错，不是也会报错）
  - 使用作用域运算符可以回避虚函数的机制 `double ans = base->Base::f();`

## 抽象基类
  - 纯虚函数
    - 在虚函数体的位置（声明语句的分号前）书写 `=0` 就可以将一个虚函数说明为纯虚函数
    - `=0` 只能出现在类内部的虚函数声明语句处
    - 可以为纯虚函数提供定义，不过函数体必须定义在类外部
  - 含有纯虚函数的类是抽象基类
  - 不能实例化一个抽象基类

## 访问控制与继承
  - `protected` 成员
    - 对于类的用户来说是不可访问的
    - 对于派生类和友元来说是可访问的
  - `public`、`private` 和 `protected` 继承
    - 控制派生类用户（包括派生类的派生类在内）对于基类成员的访问权限
  - 友元与继承
    - 友元关系不能继承
  - 通过 `using` 声明改变个别成员的可访问性
    - 通过在类的内部使用 `using` 声明语句，可以将该类的直接过间接基类的任何可访问成员（可访问的，如非私有成员）标记出来
    - `using` 声明语句中名字的访问权限有该 `using` 声明语句之前的访问说明符决定
  - 默认的继承保护级别
    - class 定义的派生类是私有继承，struct 定义的派生类是公有继承

## 继承中的类作用域
  - 每个类定义自己的作用域
  - 派生类的作用与嵌套在其基类的作用域**之内**
  - 派生类也能重用定义在其直接或间接基类的名字，此派生类的成员将隐藏同名（函数亦如此）的基类成员
  - 一如往常，名字查找优先于类型检查
    - 函数（同名即使参数列表不一样）隐藏（注意虚函数，形参列表不一样就会被隐藏）
    - 一旦名字找到，编译器不再继续查找
  - 通过基类调用隐藏的虚函数
- 虚析构函数
  - 在基类中将析构函数定义成虚函数确保多态时执行正确的析构函数版本
  - 虚析构函数将阻止合成移动操作
- 合成拷贝控制与继承
  - 对类本身的成员一次进行初始化、赋值或销毁的操作
  - 使用直接基类对应的操作（是可访问的并且不是一个被删除的函数）对直接基类部分进行初始化、赋值或销毁操作
  - 如果基类中的默认构造函数、拷贝构造函数、拷贝赋值运算符或析构函数是被删除的函数或者不可访问的，则派生类中对应的成员是被删除的
  - 如果在基类中有一个不可访问或删除掉的析构函数，则拍摄了还总合成的默认和拷贝构造函数是被删除的
  - 编译器不会自动合成一个删除掉的移动操作
- 派生类的拷贝控制成员
  - 通常使用对应的基类构造函数初始化对象的基类部分
  - 派生类的赋值运算符也必须**显式地**为基类部分赋值
  - 派生类析构函数只负责销毁有派生类自己分配的资源
  - 在构造函数和析构函数中调用虚函数：执行与构造函数或虚构函数所属类型相对应的虚函数版本
- 继承的构造函数
  - 派生类能够重用其直接基类定义的构造函数
  - using语句作用与构造函数，令编译器产生代码（using作用其他，只是让某个名字在当前作用域可见）
  - 一个构造函数的using声明不会改变该构造函数的访问级别
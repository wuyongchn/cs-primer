# 时间堆
网络程序需要处理一些定时事件，比如周期性地检测一个连接是否正常。时间堆是组织定时器的一种高效方案，它将所有定时器中距超时时间剩余时间最少的一个定时器的超时值作为心博间隔。这样，一旦搏函数 tick 被调用，超时时间最小的定时器必然到期，我们就可以在 tick 函数中处理该定时器。然后，再次从剩余的定时器中找出超时时间最小的一个，并将这个超时值设置为下一次心搏间隔，如此反复。

时间堆采用最小堆数据结构。最小堆是指每个结点的值都小于或等于其字节点的值的完全二叉树。

## 时间戳的表示
Linux 中获取当前时间的函数

|函数|数据结构|精度|
|:-|:-|:-:|
|time(2)|time_t|秒|
|ftime(3)|struct timeb|毫秒|
|gettimeofday(2)|struct timeval|微秒|
|clock_gettime(2)|struct timespec|纳秒|

参考 muduo 网络库，选择 gettimeofday(2) 作为获取当前时间的函数，理由如下：
- 在 x86-64 平台上，gettimeofday(2) 不是系统调用，而是在用户态实现的。调用时不会陷入内核而引起上下文切换
- gettimeofday(2) 的精度为 1 微秒，足以满足日常使用的需求

Timestamp 类用一个 uint64_t 类型的变量来记录从 UNIX Epoch 到现在的微秒数

## 定时器的标识
当新建一个定时器，如何标识呢？特别是需要取消一个定时器的时候，如何找到一个定时器？

TimerHeap::TimerID 就是为标识一个定时器。每个定时器都附加一个唯一的 uint64_t 类型的序号值。除此之外，还有一个 weak_ptr 类型的智能指针指向其标识的定时器。

## 定时器在堆中的位置
当插入或者取消一个定时器时，需要通过堆的上滤或下滤操作。也就是定时器在堆中的位置不是固定的。所以定时器中需要有一个成员保存当前位于堆的哪个位置，在上滤或下滤时跟着改变。当需要取消一个定时器的时候，就可以通过 TimerHeap::TimerID 的指针直接找到其表示的定时器位于堆的位置
## 总结
1. select(2)，poll(2) 以轮询的方式检查 fd 集合，轮询一遍没有就绪事件发生就会将自己挂起，等待监视的文件将自己唤醒（超时和信号都可以唤醒）。而 epoll(7) 是设备就绪时，调用回调函数，把就绪 fd 放入就绪链表中，并唤醒在 epoll_wait(2) 中进入睡眠的进程。虽然都要睡眠和交替，但是 select(2) 和 poll(2) 在“醒着”的时候要遍历整个 fd 集合，而 epoll(7) 在“醒着”的时候只要判断一下就绪链表是否为空就行了，这节省了大量的 CPU 时间。这就是回调机制带来的性能提升。
2. select(2) 和 poll(2) 每次调用都要把 fd 集合从用户态往内核态拷贝一次，而 epoll(7) 只要一次拷贝，这也能节省不少的开销。
3. 应用场景  
  - select(2) 的超时时间 timeout 参数精度为纳秒，而 poll(2) 和 epoll(7) 为微秒，因此 select(2) 更加适用于实时性要求比较高的场景。select(2) 可移植性更好，几乎被所有主流平台所支持。 
  - poll(2) 没有最大描述符数量的限制，如果平台支持并且对实时性要求不高，应该使用 poll(2) 而不是 select(2)。
  - epoll(7) 只能运行在 Linux 平台上，有大量的描述符需要同时轮询，并且这些连接最好是长连接（不会频繁地调用 epoll_clt(2) 进行事件的注册、修改和移除，频繁系统调用降低效率）。需要同时监控小于 1000 个描述符，就没有必要使用 epoll(7)，因为这个应用场景下并不能体现 epoll(7) 的优势。
4. select(2)/poll(2)/epoll(7) 区别

|--|select(2)|poll(2)|epoll(7)|
|:-:|:-:|:-:|:-:|
|操作方式|遍历|遍历|回调|
|底层实现|数组|链表|红黑树|
|IO效率|每次线性遍历，O(n)|每次线性遍历，O(n)|调用回调函数，O(k)|
|最大连接数|1024(x86)或2048(x64)|无上限|无上限|
|fd拷贝|每次调用，从用户态烤到内核态|每次调用，从用户态烤到内核态|调用 epoll_ctl(2) 是拷贝进内存并保存，之后调用 epoll_wait(2) 只拷贝就绪事件到用户空间|

5. epoll(7) 并不是新添加到系统的黑科技，而是原有系统接口的组合。可以看到，select(2) 和 poll(2) 也利用了虚拟文件系统poll 机制，只不过仅仅是唤醒 do_select() 或者 do_poll() 进程，而 epoll(7) 的实现中就绪文件不仅唤醒 epoll_wait(2) 进程，在这之前还将就绪的事件添加到就绪的队列，减少了唤醒之后的遍历所有文件描述符检查就绪工作，而是仅仅检查处于就绪链表上的事件，复杂度大大减少。
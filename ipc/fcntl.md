## 概述
记录上锁（record locking）是读写锁的一致扩展类型，它可用于具有亲缘关系或无亲缘关系的进程之间共享某个文件的读与写。被锁住的文件通过其描述符访问，执行上锁操作的函数是 fcntl()。这种类型的锁通常在内核中维护，其属主是由属主的进程 ID 表示的。这意味这这些锁用于不同进程间的上锁，而不是用于同一进程内不同线程间的上锁

## 对比记录上锁与文件上锁
Posix 记录上锁定义了一个特殊的字节范围以指定整个文件，它的起始偏移为 0（文件的开头），长度也为 0。

术语粒度用于标记能被锁住的对象的大小。对于 Posix 记录上锁来说，粒度就是单个字节。通常情况下粒度越小，允许同时使用的用户数就越多。

## Posix  fcntl 记录上锁
```
#include <fcntl.h>
/* @param
 * fd：描述符
 * cmd：命令（F_SETLK、F_SETLKW、F_GETLK）
 * return：出错返回 -1，成功返回值取决于 cmd
 */
int fcntl(int fd, int cmd, .../*struct flock *arg*/);
```
用于记录上锁的 cmd 参数共有三个值，这三个命令要求第三个参数 arg 指向某个 flock 结构的指针
```
struct flock {
  short l_type;   /* F_RDLCK, F_WRLCK, F_UNLCK */
  short l_whence; /* SEEK_SET, SEEK_CUR, SEEK_END */
  off_t l_start;  /* relative starting offset in bytes */
  off_t l_len;    /* #bytes; 0 means until end-of-file */
  pid_t l_pid;    /* PID retureend by F_GETLK */
};
```
三个命令如下：
- F_SETLK：获取（l_type 成员为 F_RDLCK 或 F_WRLCK ）或释放（l_type 成员为 F_UNLCK）由 arg 指向的 flock 结构所描述的锁。如果无法将该锁授予调用进程，该函数就立即返回一个 EACESS 或 EAGAIN 错误而不阻塞
- F_SETLKW：该命令与上一个命令类似，不过如果无法将所请求的锁授予调用进程，调用进程将阻塞到该锁能够授予为止
- F_GETLK：检查有 arg 指向的锁以确定是否有某个已存在的锁会妨碍将新锁授予调用进程。如果当前没有这样的锁存在，有 arg 指向的 flock 结构的 l_type 成员被设置为 F_UNLCK。否则，关于这个已存在锁的信息将在由 arg 指向的 flock 结构中返回（该结构内容由 fcntl() 函数覆写），其中包括持有该锁的进程的 PID

提供 F_GETLK 命令的原因在于：当执行 F_SETLK 命令的 fcntl() 函数返回一个错误时，导致该错误的某个锁的信息可由 F_GETLK 命令返回，从而允许我们确定是哪个进程锁住类所请求的文件区以及上锁方式（读出锁或写入锁）。但是即使是这样的情形， F_SETLK 命令也可能返回该文件区已解锁的信息，因为在 F_SETLK 和 F_GETLK 命令之间，该文件区可能被解锁。

flock 结构描述锁的类型（读出锁或写入锁）以及待锁住的字节范围。起始字节偏移是作为一个相对偏移（l_start 成员）伴随其解释（l_whence 成员）指定的。l_whence 成员有以下三个取值：
-  SEEK_SET ： l_start 相对于文件的开头解释
-  SEEK_CUR ： l_start 相对文件的当前字节偏移（当前读写指针位置）解释
-  SEEK_END ： l_start 相对于文件的末尾解释

 l_len 成员指定从该偏移开始的连续字节数。长度为 0 意思是“从起始偏移到文件偏移的最大可能值”

 fcntl 记录上锁既可以用于读也可以用于写，对于一个文件的任意字节，最多只能存在一种类型的锁（读入锁或写入锁）。而且，一个给定字节可以有多个读出锁，但只能有一个写入锁。

对于一个打开着某个文件的给定进程来说，当它关闭该文件的所有描述符或它本身终止时，与该文件关联的所有锁都被删除。锁不能通过 fork() 由子进程继承

记录上锁不应该同标准IO函数库一块使用，因为该函数库会执行内部缓冲。当某个文件需上锁时，为避免问题，应对它使用 read() 和 write()

## 劝告性上锁
Posix记录上锁称为劝告性上锁。其含义是内核维护着已由各个进程上锁的所有文件的正确信息，但是它不能防止一个进程写已由另一个进程读锁定的某个文件。类似地，它也不能防止一个进程读已由另一个进程写锁定的某个文件。一个进程能够无视一个劝告性锁而写一个读锁定文件，或者读一个写锁定文件，前提是该进程有读或写该文件的足够权限

劝告性锁对于协作进程是足够了

## 强制性上锁
使用强制性锁后，内核检查每个 read() 和 write() 请求，以验证其操作不会干扰由某个进程持有的某个锁。对于通常的阻塞式描述符，与某个强制性锁冲突的 read() 或 write() 将把调用进程投入睡眠，直到该锁释放为止。对于非阻塞式描述符，与某个强制性锁冲突的 read() 或 write() 将导致它们返回一个 EAGAIN 错误

## 启动一个守护进程的唯一副本
记录上锁的一个常见用途是确保某个程序（例如守护程序）在任何时刻只有一个副本在运行

## 文件作锁用
Posix.1保证，如果以 O_CREAT （若文件不存在则创建它）和 O_EXCL （独占打开）标志调用 open() 函数，那么一旦该文件已经存在，该函数就返回一个错误。而且考虑到其他进程的存在，检查该文件是否存在和创建该文件必须是原子的。因此，我们可以把以这种技巧创建的文件作为锁使用。Posix.1保证任何时候只有一个进程能够创建这样的文件（也就是获取锁），释放这样的锁只需要 unlink() 该文件。

这种技巧存在以下三个问题
1. 如果当前持有该锁的进程没有释放它就终止，那么其文件名并未删除。（可以更具最近访问时间，大于一定时间未曾访问，就假设它已被遗忘）
2. 如果另外某个进程已打开类锁文件，那么当前进程只能轮询调用 open() 。（可以 sleep 1秒）
3. 调用 open() 和 unlink() 创建和删除一个额外的文件涉及文件系统的访问，这通常比调用 fcntl() 两次（获取和释放）锁花时间长得多